#!/usr/bin/env python
# -*- coding: utf-8; -*-
"""
Copyright (C) 2007-2012 Lincoln de Sousa <lincoln@minaslivre.org>
Copyright (C) 2007 Gabriel Falc√£o <gabrielteratos@gmail.com>

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License as
published by the Free Software Foundation; either version 2 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public
License along with this program; if not, write to the
Free Software Foundation, Inc., 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.
"""
from __future__ import absolute_import

from gi.repository import Gtk
from gi.repository import Gdk
from gi.repository import GdkX11
from gi.repository import GdkPixbuf
from gi.repository import GConf
from gi.repository import Vte
from gi.repository import Notify
import dbus

import os
import sys
import signal
import posix
from thread import start_new_thread
from time import sleep

import guake.globalhotkeys
from guake.simplegtkapp import SimpleGtkApp, bindtextdomain
from guake.prefs import PrefsDialog, GKEY
from guake.dbusiface import DbusManager, DBUS_NAME, DBUS_PATH
from guake.common import test_gconf, pixmapfile, gladefile, ShowableError, _
from guake.globals import NAME, VERSION, LOCALE_DIR, KEY, \
    ALIGN_LEFT, ALIGN_RIGHT, ALIGN_CENTER
from guake.conf import GConfHandler, GConfKeyHandler
from guake.terminal import TerminalBox

Notify.init('Guake!')

# Loading translation
bindtextdomain(NAME, LOCALE_DIR)

class PromptQuitDialog(Gtk.MessageDialog):
    """Prompts the user whether to quit or not if there are procs running.
    """
    def __init__(self, parent, running_procs):
        super(PromptQuitDialog, self).__init__(
            parent,
            Gtk.DialogFlags.MODAL | Gtk.DialogFlags.DESTROY_WITH_PARENT,
            Gtk.MessageType.QUESTION, Gtk.ButtonsType.YES_NO)

        self.set_keep_above(True)
        self.set_markup(_('Do you really want to quit Guake!?'))
        if running_procs == 1:
            self.format_secondary_markup(
                _("<b>There is one process still running.</b>")
            )
        elif running_procs > 1:
            self.format_secondary_markup(
                _("<b>There are %d processes running.</b>" % running_procs)
            )


class AboutDialog(SimpleGtkApp):
    """The About Guake dialog class
    """
    def __init__(self):
        super(AboutDialog, self).__init__(gladefile('about.ui'))
        dialog = self.get_widget('aboutdialog')

        # images
        ipath = pixmapfile('guake-notification.png')
        img = GdkPixbuf.Pixbuf.new_from_file(ipath)
        dialog.set_property('logo', img)

        dialog.set_name('Guake!')
        dialog.set_version(VERSION)


class Guake(SimpleGtkApp):
    """Guake main class. Handles specialy the main window.
    """
    def __init__(self):
        super(Guake, self).__init__(gladefile('guake.ui'))
        self.client = GConf.Client.get_default()

        # setting global hotkey and showing a pretty notification =)
        guake.globalhotkeys.init()

        # trayicon!
        img = pixmapfile('guake-tray.png')
        self.tray_icon = Gtk.StatusIcon.new_from_file(img)
        self.tray_icon.set_tooltip_text(_('Guake Terminal'))
        self.tray_icon.connect('popup-menu', self.show_menu)
        self.tray_icon.connect('activate', self.show_hide)

        # important widgets
        self.window = self.get_widget('window-root')
        self.notebook = self.get_widget('notebook-teminals')

        # Adding the `new tab' button as an action widget of the tabs
        # notebook.
        add_button = Gtk.Button.new_from_stock(Gtk.STOCK_NEW)
        add_button.connect('clicked', self.add_tab)
        add_button.show()
        self.notebook.set_action_widget(add_button, Gtk.PackType.END)

        # double click stuff
        def double_click(hbox, event):
            """Handles double clicks on tabs area and when receive
            one, calls add_tab.
            """
            # Gdk.EventType.2BUTTON_PRESS is not working in python because
            # it starts with number so use Gdk.EventType(value = 5) to construct
            # 2BUTTON_PRESS event type
            if event.button == 1 and \
                event.type == Gdk.EventType(value=5):
                self.add_tab()

        self.notebook.connect('button-press-event', double_click)

        self.mainframe = self.get_widget('mainframe')
        self.resizer = self.get_widget('resizer')
        self.context_menu = self.get_widget('context-menu')

        # check and set ARGB for real transparency
        screen = self.window.get_screen()
        self.has_argb = False
        visual = screen.get_rgba_visual()
        if visual and screen.is_composited():
            self.window.set_visual(visual)
            self.has_argb = True
        else:
            self.has_argb = False

        # List of Vte.Terminal widgets, it will be useful when needed
        # to get a widget by the current page in self.notebook
        self.term_list = []

        # This is the pid of shells forked by each terminal. Will be
        # used to kill the process when closing a tab
        self.pid_list = []

        # holds fullscreen status
        self.is_fullscreen = False

        # holds the timestamp of the hide triggered in losefocus event
        self.losefocus_hide_time = 0

        # Flag to prevent guake hide when window_losefocus is true and
        # user tries to use the context menu.
        self.showing_context_menu = False
        def hide_context_menu(menu):
            """Turn context menu flag off to make sure it is not being
            shown.
            """
            self.showing_context_menu = False
        self.get_widget('context-menu').connect('hide', hide_context_menu)
        self.get_widget('tab-menu').connect('hide', hide_context_menu)
        self.window.connect('focus-out-event', self.on_window_losefocus)

        # Handling the delete-event of the main window to avoid
        # problems when closing it.
        def destroy(*args):
            self.hide()
            return True
        self.window.connect('delete-event', destroy)

        # Flag to completely disable losefocus hiding
        self.disable_losefocus_hiding = False

        # this line is important to resize the main window and make it
        # smaller.
        geometry = Gdk.Geometry()
        geometry.min_width = 1
        geometry.min_height = 1
        self.window.set_geometry_hints(None, geometry, Gdk.WindowHints.MIN_SIZE)

        # resizer stuff
        self.resizer_held = False
        self.resizer.connect('motion-notify-event', self.on_resizer_drag)
        self.resizer.connect('button-press-event', self.on_resizer_button)
        self.resizer.connect('button-release-event', self.on_resizer_button)

        # adding the first tab on guake
        self.add_tab()

        # loading and setting up configuration stuff
        GConfHandler(self)
        GConfKeyHandler(self)
        self.hotkeys = guake.globalhotkeys.GlobalHotkey()
        self.load_config()

        key = self.client.get_string(GKEY('show_hide'))
        keyval, mask = Gtk.accelerator_parse(key)
        label = Gtk.accelerator_get_label(keyval, mask)
        filename = pixmapfile('guake-notification.png')

        if not self.hotkeys.bind(key, self.show_hide):
            notification = Notify.Notification.new(
                _('Guake!'),
                _('A problem happened when binding <b>%s</b> key.\n'
                  'Please use Guake Preferences dialog to choose another '
                  'key (The trayicon was enabled)') % label, filename)
            notification.show()
            self.client.set_bool(KEY('/general/use_trayicon'), True)
        elif self.client.get_bool(KEY('/general/use_popup')):
            # Pop-up that shows that guake is working properly (if not
            # unset in the preferences windows)
            notification = Notify.Notification.new(
                _('Guake!'),
                _('Guake is now running,\n'
                  'press <b>%s</b> to use it.') % label, filename)
            notification.show()

    @property
    def current_tab(self):
        return self.notebook.get_nth_page(self.notebook.get_current_page())

    @property
    def current_label(self):
        return self.notebook.get_tab_label(self.current_tab)

    def execute_command(self, command, tab=None):
        """Execute the `command' in the `tab'. If tab is None, the
        command will be executed in the currently selected
        tab. Command should end with '\n', otherwise it will be
        appended to the string.
        """
        if not self.term_list:
            self.add_tab()

        if command[-1] != '\n':
            command += '\n'

        index = self.notebook.get_current_page()
        self.term_list[tab or index].feed_child(command, -1)

    def on_resizer_button(self, widget, event):
        """Callback called when clicking on the resizer"""
        self.resizer_held = event.type == Gdk.EventType.BUTTON_PRESS

    def on_resizer_drag(self, widget, event):
        """Method that handles the resize drag. It does not actuall
        moves the main window. It just set the new window size in
        GConf.
        """
        if not self.resizer_held:
            return

        screen, x, y = event.device.get_position()

        max_height = self.window.get_screen().get_height()
        percent = y / (max_height / 100)

        if percent < 1:
            percent = 1

        self.client.set_int(KEY('/general/window_height'), int(percent))

    def on_window_losefocus(self, window, event):
        """Hides terminal main window when it loses the focus and if
        the window_losefocus gconf variable is True.
        """
        if self.disable_losefocus_hiding or self.showing_context_menu:
            return

        value = self.client.get_bool(KEY('/general/window_losefocus'))
        visible = window.get_property('visible')
        if value and visible:
            self.losefocus_hide_time = \
                GdkX11.x11_get_server_time(self.window.window)
            self.hide()

    def show_menu(self, status_icon, button, activate_time):
        """Show the tray icon menu.
        """
        menu = self.get_widget('tray-menu')
        # FIXME: we should use Gtk.StatusIcon.position_menu here as
        # callback but it crashes in Gtk3
        menu.popup_for_device(
            None, None, None, None, None, button, activate_time)

    def show_context_menu(self, terminal, event):
        """Show the context menu, only with a right click on a vte
        Terminal.
        """
        if event.button != 3:
            return False

        self.showing_context_menu = True
        guake_clipboard = Gtk.Clipboard.get(Gdk.atom_intern("CLIPBOARD", True))
        self.get_widget('context_paste').set_sensitive(
            guake_clipboard.wait_is_text_available())
        self.context_menu.popup_for_device(
            None, None, None, None, None, 3,
            Gtk.get_current_event_time())
        return True

    def show_rename_dialog(self, target, event):
        """On double-click over a tab, show the rename dialog.
        """
        if event.button == 1:
            if event.type == Gdk.EventType(value=5): # 5 == GDK_2BUTTON_PRESS
                self.accel_rename()
                self.set_terminal_focus()
                return

    def show_tab_menu(self, target, event):
        """Shows the tab menu with a right click. After that, the
        focus come back to the terminal.
        """
        if event.button == 3:
            self.showing_context_menu = True
            menu = self.get_widget('tab-menu')
            menu.popup(None, None, None, None, 3, event.get_time())
        self.set_terminal_focus()

    def show_about(self, *args):
        """Hides the main window and creates an instance of the About
        Dialog.
        """
        self.hide()
        AboutDialog()

    def show_prefs(self, *args):
        """Hides the main window and creates an instance of the
        Preferences window.
        """
        self.hide()
        PrefsDialog().show()

    def show_hide(self, *args):
        """Toggles the main window visibility
        """
        event_time = self.hotkeys.get_current_event_time()

        # do nothing if hide has occured in losefocus event in "future"
        if not (self.losefocus_hide_time and \
                    self.losefocus_hide_time >= event_time):
            if not self.window.get_property('visible'):
                self.show()
                self.set_terminal_focus()
            else:
                self.hide()
 
    def show(self):
        """Shows the main window and grabs the focus on it.
        """
        # setting window in all desktops
        self.get_widget('window-root').stick()

        # add tab must be called before window.show to avoid a
        # blank screen before adding the tab.
        if not self.term_list:
            self.add_tab()

        x, y, width, height = self.get_final_window_rect()
        self.window.move(x, y)
        self.window.resize(width, height)
        self.window.show_all()
        self.client.notify(KEY('/general/window_height'))

        time = GdkX11.x11_get_server_time(self.window.window)
        self.window.present_with_time(time)

        # This is here because vte color configuration works only
        # after the widget is shown.
        self.client.notify(KEY('/style/font/color'))
        self.client.notify(KEY('/style/background/color'))

    def hide(self):
        """Hides the main window of the terminal and sets the visible
        flag to False.
        """
        self.window.hide() # Don't use hide_all here!

    def get_final_window_rect(self):
        """Gets the final size of the main window of guake. The height
        is the window_height property, width is window_width and the
        horizontal alignment is given by window_alignment.
        """
        screen = self.window.get_screen()
        height_percent = self.client.get_int(KEY('/general/window_height'))
        width_percent = 100
        halignment = self.client.get_int(KEY('/general/window_halignment'))

        # get the rectangle just from the first/default monitor in the
        # future we might create a field to select which monitor you
        # wanna use
        geometry = screen.get_monitor_geometry(0)

        x = 0
        y = 0
        width = geometry.width * width_percent / 100
        height = geometry.height * height_percent / 100

        if width < geometry.x:
            if halignment == ALIGN_CENTER:
                x = (geometry.width - width) / 2
            elif halignment == ALIGN_LEFT:
                x = 0
            elif halignment == ALIGN_RIGHT:
                x = geometry.width - width

        return x, y, width, height

    def get_running_fg_processes(self):
        """Get the number processes for each terminal/tab. The code is
        taken from gnome-terminal.
        """
        total_procs = 0
        term_idx = 0
        for terminal in self.term_list:
            fdpty = terminal.get_pty_object().get_fd()
            term_pid = self.pid_list[term_idx]
            fgpid = posix.tcgetpgrp(fdpty)
            if not (fgpid == -1 or fgpid == term_pid):
                total_procs += 1
            term_idx += 1
        return total_procs

    # -- configuration --

    def load_config(self):
        """"Just a proxy for all the configuration stuff.
        """
        self.client.notify(KEY('/general/use_trayicon'))
        self.client.notify(KEY('/general/prompt_on_quit'))
        self.client.notify(KEY('/general/window_tabbar'))
        self.client.notify(KEY('/general/window_ontop'))
        self.client.notify(KEY('/general/window_height'))
        self.client.notify(KEY('/general/use_scrollbar'))
        self.client.notify(KEY('/general/history_size'))
        self.client.notify(KEY('/general/show_resizer'))
        self.client.notify(KEY('/general/use_vte_titles'))
        self.client.notify(KEY('/style/font/style'))
        self.client.notify(KEY('/style/font/color'))
        self.client.notify(KEY('/style/font/palette'))
        self.client.notify(KEY('/style/background/color'))
        self.client.notify(KEY('/style/background/image'))
        self.client.notify(KEY('/style/background/transparency'))
        self.client.notify(KEY('/general/use_default_font'))
        self.client.notify(KEY('/general/compat_backspace'))
        self.client.notify(KEY('/general/compat_delete'))

    def accel_quit(self, *args):
        """Callback to prompt the user whether to quit Guake or not.
        """
        if self.client.get_bool(KEY('/general/prompt_on_quit')):
            procs = self.get_running_fg_processes()
            if procs >= 1:
                dialog = PromptQuitDialog(self.window, procs)
                response = dialog.run() == Gtk.ResponseType.YES
                dialog.destroy()
                if response:
                    Gtk.main_quit()
            else:
                Gtk.main_quit()
        else:
            Gtk.main_quit()

    def accel_add(self, *args):
        """Callback to add a new tab. Called by the accel key.
        """
        self.add_tab()
        return True

    def accel_prev(self, *args):
        """Callback to go to the previous tab. Called by the accel key.
        """
        if self.notebook.get_current_page() == 0:
            self.notebook.set_current_page(self.notebook.get_n_pages() - 1)
        else:
            self.notebook.prev_page()
        return True

    def accel_next(self, *args):
        """Callback to go to the next tab. Called by the accel key.
        """
        if self.notebook.get_current_page() + 1 == self.notebook.get_n_pages():
            self.notebook.set_current_page(0)
        else:
            self.notebook.next_page()
        return True

    def accel_rename(self, *args):
        """Callback to show the rename tab dialog. Called by the accel
        key.
        """
        self.on_rename_activate()
        return True

    def accel_copy_clipboard(self, *args):
        """Callback to copy text in the shown terminal. Called by the
        accel key.
        """
        current_term = self.term_list[self.notebook.get_current_page()]

        if current_term.get_has_selection():
            current_term.copy_clipboard()
        elif current_term.matched_value:
            guake_clipboard = Gtk.clipboard_get()
            guake_clipboard.set_text(current_term.matched_value)

        return True

    def accel_paste_clipboard(self, *args):
        """Callback to paste text in the shown terminal. Called by the
        accel key.
        """
        pos = self.notebook.get_current_page()
        self.term_list[pos].paste_clipboard()
        return True

    def accel_toggle_fullscreen(self, *args):
        """Callback toggle the fullscreen status of the main window. It
        uses the toolbar_visible_in_fullscreen variable from gconf to
        decide if the tabbar will or not be shown. Called by the accel
        key.
        """
        val = self.client.get_bool(KEY('general/toolbar_visible_in_fullscreen'))

        if not self.fullscreen:
            self.window.fullscreen()
            self.fullscreen = True

            # The resizer widget really don't need to be shown in
            # fullscreen mode, but tabbar will only be shown if a hidden
            # gconf key is false.
            self.resizer.hide()
            if not val:
                # FIXME: There's something wrong here, if we just hide
                # it, when will we show it again?!?! Let's disable this
                # until answering this question.
                #self.notebook.set_show_tabs(False)
                pass
        else:
            self.unfullscreen()
        return True

            # making sure that tabbar and resizer will come back to
            # their default state.
            self.client.notify(KEY('/general/window_tabbar'))
            self.client.notify(KEY('/general/show_resizer'))

            # make sure the window size is correct after returning from
            # fullscreen
            self.client.notify(KEY('/general/window_height'))
        return True

    # -- callbacks --

    def on_terminal_exited(self, term, widget):
        """When a terminal is closed, shell process should be killed,
        this is the method that does that, or, at least calls
        `delete_tab' method to do the work.
        """
        self.delete_tab(self.notebook.page_num(widget), kill=False)

    def on_terminal_title_changed(self, vte, box):
        """Simple callback to change the current tab label when vte says
        to do so.
        """
        if self.client.get_bool(KEY("/general/use_vte_titles")):
            self.current_label.set_text(vte.get_window_title())

    def on_rename_activate(self, *args):
        """Shows a dialog to rename the current tab.
        """

        entry = Gtk.Entry()
        entry.set_text(self.current_label.get_text())
        entry.set_property('can-default', True)
        entry.show()

        dialog = Gtk.Dialog(
            _("Rename tab"),
            self.window,
            Gtk.DialogFlags.MODAL | Gtk.DialogFlags.DESTROY_WITH_PARENT,
            (Gtk.STOCK_CANCEL, Gtk.ResponseType.REJECT,
             Gtk.STOCK_OK, Gtk.ResponseType.ACCEPT))

        dialog.set_size_request(300, -1)
        dialog.set_border_width(4)
        dialog.set_default_response(Gtk.ResponseType.ACCEPT)
        dialog.add_action_widget(entry, Gtk.ResponseType.ACCEPT)
        entry.reparent(dialog.get_content_area())

        self.disable_losefocus_hiding = True
        response = dialog.run()
        self.disable_losefocus_hiding = False

        if response == Gtk.ResponseType.ACCEPT:
            self.current_label.set_text(entry.get_text())

        dialog.destroy()
        self.set_terminal_focus()

    def on_close_activate(self, *args):
        """Tab context menu close handler
        """
        self.delete_tab(self.notebook.get_current_page())

    def on_drag_data_received(self, widget, context,
                              x, y,
                              selection,
                              target,
                              timestamp,
                              box):
        droppeduris = selection.get_uris()

        # url-unquote the list, strip file:// schemes, handle .desktop-s
        pathlist = []
        app = None
        for uri in droppeduris:
            scheme, _, path, _, _ = urlsplit(uri)

            if scheme!="file":
                pathlist.append(uri)
            else:
                filename = url2pathname(path)

                desktopentry = DesktopEntry()
                try:
                    desktopentry.parse(filename)
                except xdg.Exceptions.ParsingError:
                    pathlist.append(filename)
                    continue

                if desktopentry.getType()=='Link':
                    pathlist.append(desktopentry.getURL())

                if desktopentry.getType()=='Application':
                    app = desktopentry.getExec()

        if app and len(droppeduris)==1:
            text = app
        else:
            text = str.join("", (shell_quote(path)+" " for path in pathlist))

        box.terminal.feed_child(text)
        return True

    # -- tab related functions --

    def close_tab(self, *args):
        """Closes the current tab.
        """
        self.delete_tab(self.notebook.get_current_page())

    def rename_current_tab(self, new_text):
        """Sets the text of the current label.
        """
        self.current_label.set_text(new_text)

    def get_current_dir(self):
        """Gets the working directory of the current tab to create a new
        one in the same dir.
        """
        active_pagepos = self.notebook.get_current_page()
        directory = os.path.expanduser('~')
        if active_pagepos >= 0:
            cwd = os.readlink("/proc/%d/cwd" % self.pid_list[active_pagepos])
            if os.path.exists(cwd):
                directory = cwd
        return directory

    def get_fork_params(self, directory=None):
        """Return all parameters to be passed to the fork_command method
        of a vte terminal. Params returned can be expanded by the
        `params' parameter that receive a dictionary.
        """
        # use dictionary to pass named params to work around command
        # parameter in fork_command not accepting None as argument.
        # When we pass None as command, vte starts the default user
        # shell.
        params = []
        params.append(0)      # 0: pty_flags
        params.append('~/')   # 1: working_directory
        params.append([])     # 2: argv
        params.append(None)   # 3: envv
        params.append(0)      # 4: spawn_flags
        params.append(None)   # 5: child_setup
        params.append(None)   # 6: child_setup_data

        shell = self.client.get_string(KEY('/general/default_shell'))
        if shell and os.path.exists(shell):
            params[2].append(shell)

        login_shell = self.client.get_bool(KEY('/general/use_login_shell'))
        if login_shell:
            params[2].append('-')
        else:
            params[0] = Vte.PtyFlags.NO_LASTLOG

        if self.client.get_bool(KEY('/general/open_tab_cwd')):
            params[1] = self.get_current_dir()

        # Letting caller change/add values to fork params.
        if directory:
            params[1] = directory

        # Environment variables are not actually parameters but they
        # need to be set before calling terminal.fork_command()
        # method. So I found this place good to do it.
        self.update_proxy_vars()
        return params

    def update_proxy_vars(self):
        """This method updates http{s,}_proxy environment variables with
        values found in GConf.
        """
        proxy = '/system/http_proxy/'
        if self.client.get_bool(proxy + 'use_http_proxy'):
            host = self.client.get_string(proxy + 'host')
            port = self.client.get_int(proxy + 'port')
            if self.client.get_bool(proxy + 'use_same_proxy'):
                ssl_host = host
                ssl_port = port
            else:
                ssl_host = self.client.get_string('/system/proxy/secure_host')
                ssl_port = self.client.get_int('/system/proxy/secure_port')

            if self.client.get_bool(proxy + 'use_authentication'):
                auth_user = self.client.get_string(
                    proxy + 'authentication_user')
                auth_pass = self.client.get_string(
                    proxy + 'authentication_password')
                os.environ['http_proxy'] = 'http://%s:%s@%s:%d' % (
                    auth_user, auth_pass, host, port)
                os.environ['https_proxy'] = 'http://%s:%s@%s:%d' % (
                    auth_user, auth_pass, ssl_host, ssl_port)
            else:
                os.environ['http_proxy'] = 'http://%s:%d' % (host, port)
                os.environ['https_proxy'] = 'http://%s:%d' % (
                    ssl_host, ssl_port)

    def add_tab(self, directory=None):
        """Adds a new tab to the terminal notebook.
        """
        box = TerminalBox()
        box.terminal.connect('button-press-event', self.show_context_menu)
        box.terminal.connect('child-exited', self.on_terminal_exited, box)
        box.terminal.connect('window-title-changed',
                             self.on_terminal_title_changed, box)
        box.terminal.connect('drag-data-received',
                             self.on_drag_data_received,
                             box)
        box.show()

        self.term_list.append(box.terminal)

        final_params = self.get_fork_params(directory)
        success, pid = box.terminal.fork_command_full(*final_params)
        self.pid_list.append(pid)

        # Adding a new radio button to the tabbar
        label = box.terminal.get_window_title() or _("Terminal")
        self.notebook.append_page(box, Gtk.Label(label))
        self.notebook.set_current_page(self.notebook.page_num(box))
        box.terminal.grab_focus()
        self.load_config()

    def delete_tab(self, pagepos, kill=True):
        """This function will destroy the notebook page, terminal and
        tab widgets and will call the function to kill interpreter
        forked by Vte.
        """
        self.notebook.remove_page(pagepos)
        self.term_list.pop(pagepos).destroy()
        pid = self.pid_list.pop(pagepos)

        if kill:
            start_new_thread(self.delete_shell, (pid,))

        if not self.term_list:
            self.hide()
            # avoiding the delay on next Guake show request
            self.add_tab()

    def delete_shell(self, pid):
        """This function will kill the shell on a tab, trying to send a
        sigterm and if it doesn't work, a sigkill. Between these two
        signals, we have a timeout of 3 seconds, so is recommended to
        call this in another thread. This doesn't change any thing in
        UI, so you can use python's start_new_thread.
        """
        os.kill(pid, signal.SIGTERM)
        num_tries = 30

        while num_tries > 0:
            try:
                # Try to wait for the pid to be closed. If it does not
                # exist anymore, an OSError is raised and we can
                # safely ignore it.
                if os.waitpid(pid, os.WNOHANG)[0] != 0:
                    break
            except OSError:
                break
            sleep(0.1)
            num_tries -= 1

        if num_tries == 0:
            try:
                os.kill(pid, signal.SIGKILL)
                os.waitpid(pid, 0)
            except OSError:
                # if this part of code was reached, means that SIGTERM
                # did the work and SIGKILL wasnt needed.
                pass

    def set_terminal_focus(self):
        """Grabs the focus on the current tab.
        """
        page = self.notebook.get_current_page()
        self.term_list[page].grab_focus()

    def select_tab(self, tab_index):
        """Select an already added tab by its index.
        """
        page = self.notebook.get_nth_page(tab_index)
        page.set_active(True)


def handle_params(remote_object):
    """Parses the command line parameters and decide if dbus methods
    should be called or not. If there is already a guake instance
    running it will be used and a True value will be returned,
    otherwise, false will be returned.
    """
    from optparse import OptionParser
    parser = OptionParser()
    parser.add_option('-f', '--fullscreen', dest='fullscreen',
            action='store_true', default=False,
            help=_('Put Guake in fullscreen mode'))

    parser.add_option('-t', '--toggle-visibility', dest='show_hide',
            action='store_true', default=False,
            help=_('Toggles the visibility of the terminal window'))

    parser.add_option('-p', '--preferences', dest='show_preferences',
            action='store_true', default=False,
            help=_('Shows Guake preference window'))

    parser.add_option('-a', '--about', dest='show_about',
            action='store_true', default=False,
            help=_('Shows Guake\'s about info'))

    parser.add_option('-n', '--new-tab', dest='new_tab',
            action='store', default='',
            help=_('Add a new tab'))

    parser.add_option('-s', '--select-tab', dest='select_tab',
            action='store', default='',
            help=_('Select a tab'))

    parser.add_option('-g', '--selected-tab', dest='selected_tab',
            action='store_true', default=False,
            help=_('Return the selectd tab index.'))

    parser.add_option('-e', '--execute-command', dest='command',
            action='store', default='',
            help=_('Execute an arbitrary command in the selected tab.'))

    parser.add_option('-r', '--rename-tab', dest='rename_tab',
            action='store', default='',
            help=_('Rename the selected tab.'))

    parser.add_option('-q', '--quit', dest='quit',
            action='store_true', default=False,
            help=_('Says to Guake go away =('))

    options = parser.parse_args()[0]

    called_with_param = False

    if options.fullscreen:
        instance.fullscreen()

    if options.show_preferences:
        remote_object.show_prefs()
        only_show_hide = False

    if options.new_tab:
        remote_object.add_tab(options.new_tab)
        only_show_hide = False

    if options.select_tab:
        selected = int(options.select_tab)
        remote_object.select_tab(selected)
        only_show_hide = False

    if options.selected_tab:
        selected = remote_object.get_selected_tab()
        sys.stdout.write('%d\n' % selected)
        only_show_hide = False

    if options.command:
        remote_object.execute_command(options.command)
        only_show_hide = False

    if options.rename_tab:
        remote_object.rename_current_tab(options.rename_tab)
        only_show_hide = False

    if options.show_about:
        remote_object.show_about()
        only_show_hide = False

    if options.quit:
        remote_object.quit()
        only_show_hide = False

    return called_with_param

if __name__ == '__main__':
    Gtk.init_check(sys.argv)
    if not test_gconf():
        raise ShowableError(_('Guake can not init!'),
            _('Gconf Error.\n'
              'Have you installed <b>guake.schemas</b> properly?'))

    # Trying to get an already running instance of guake. If it is not
    # possible, lets create a new instance. This function will return
    # a boolean value depending on this decision.
    try:
        bus = dbus.SessionBus()
        remote_object = bus.get_object(DBUS_NAME, DBUS_PATH)
        if not handle_params(remote_object):
            # here we know that guake was called without any parameter and
            # it is already running, so, lets toggle its visibility.
            remote_object.show_hide()
    except dbus.DBusException:
        instance = Guake()
        remote_object = DbusManager(instance)
        handle_params(remote_object)
        instance.run()
